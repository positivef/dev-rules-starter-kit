# Dev Rules Starter Kit - Constitution (헌법)
#
# 프로젝트: 실행형 자산 시스템 (Executable Knowledge Base)
# 목적: 프로그램 개발 시 사용할 기준 시스템 체계
# 버전: 1.0.0
# 비준일: 2025-10-23

---

# ==============================================================================
# 메타데이터
# ==============================================================================

constitution:
  project: "Dev Rules Starter Kit"
  version: "1.0.0"
  ratified_date: "2025-10-23"
  next_review: "2026-01-23"

  philosophy: |
    이 프로젝트는 "실행형 자산 시스템(Executable Knowledge Base)"입니다.

    핵심 개념:
      - 문서가 곧 코드 (YAML 계약서 → TaskExecutor 실행)
      - Constitution(헌법)이 모든 개발의 중심
      - 증거 기반 개발 (모든 실행 결과 자동 기록)
      - 지식 자산화 (Obsidian 자동 동기화 3초)

    이 헌법은:
      - 모든 도구의 존재 이유를 정의
      - 각 도구가 어떤 조항을 검증/집행하는지 명시
      - 프로젝트 개발의 불변 원칙 제공

  scope: |
    이 헌법은 다음에 적용됩니다:
      - 모든 코드 (scripts/, tests/, src/)
      - 모든 작업 정의 (TASKS/*.yaml)
      - 모든 도구 (TaskExecutor, Validators, Analyzers)
      - 모든 문서 (docs/, claudedocs/)
      - CI/CD 파이프라인
      - 개발 워크플로우


# ==============================================================================
# 헌법 조항 (Articles)
# ==============================================================================

articles:

  # ============================================================================
  # 제1조: YAML 계약서 우선 (YAML-First Development)
  # ============================================================================

  - id: "P1"
    name: "YAML 계약서 우선"
    category: "core_workflow"
    priority: "critical"

    principle: |
      모든 중요한 작업은 YAML 계약서로 정의되어야 하며,
      TaskExecutor를 통해 실행되어야 합니다.

    requirements:
      - desc: "3개 이상의 단계가 있는 작업은 YAML로 정의"
        mandatory: true
      - desc: "새 기능 추가는 TASKS/*.yaml로 계약서 작성"
        mandatory: true
      - desc: "YAML 계약서는 다음을 포함해야 함"
        details:
          - "task_id: 고유 식별자"
          - "title: 작업 제목"
          - "acceptance_criteria: 완료 조건"
          - "commands: 실행 명령어"
          - "evidence: 증거 파일 목록"
          - "gates: 헌법 검증 게이트"

    rationale: |
      YAML 계약서는:
        - 작업을 명확하게 정의 (실행 가능한 문서)
        - 증거를 자동 수집 (재현 가능)
        - 지식으로 자산화 (Obsidian 동기화)
        - 팀원 간 작업 공유 용이

    enforcement:
      tool: "TaskExecutor"
      method: "YAML 파싱 및 실행"
      violation_severity: "high"

    examples:
      good: |
        # TASKS/FEAT-2025-10-23-01.yaml
        task_id: "FEAT-2025-10-23-01"
        title: "사용자 인증 API 추가"
        commands:
          - id: "01-implement"
            exec:
              cmd: "python"
              args: ["-m", "pytest", "tests/test_auth.py"]
        gates:
          - type: "constitutional"
            articles: ["P4", "P5"]

      bad: |
        # ❌ 그냥 코드 작성
        vim src/auth.py
        # 계약서 없음 → 증거 없음 → 지식 휘발

  # ============================================================================
  # 제2조: 증거 기반 개발 (Evidence-Based Development)
  # ============================================================================

  - id: "P2"
    name: "증거 기반 개발"
    category: "quality_assurance"
    priority: "critical"

    principle: |
      모든 실행 결과는 RUNS/evidence/에 자동으로 기록되어야 하며,
      모든 주장은 증거로 검증 가능해야 합니다.

    requirements:
      - desc: "모든 TaskExecutor 실행은 증거 생성"
        mandatory: true
      - desc: "증거는 다음을 포함"
        details:
          - "실행 로그 (JSON + 텍스트)"
          - "검증 결과 (VerificationResult)"
          - "Provenance (SHA256 해시)"
          - "타임스탬프 및 실행 환경"
      - desc: "증거는 최소 3개월 보관"
        mandatory: true

    rationale: |
      증거 기반 개발은:
        - 재현성 보장 (누가 언제 무엇을 했는지)
        - 디버깅 용이 (문제 발생 시 추적 가능)
        - 학습 가능 (과거 작업에서 배움)
        - 신뢰성 향상 (Trust Score 제공)

    enforcement:
      tool: "EvidenceLogger"
      method: "자동 로그 수집 (RUNS/evidence/)"
      violation_severity: "high"

    storage:
      location: "RUNS/evidence/YYYYMMDD/"
      format: "JSON + plain text"
      retention: "90 days"

  # ============================================================================
  # 제3조: 지식 자산화 (Knowledge Asset Management)
  # ============================================================================

  - id: "P3"
    name: "지식 자산화"
    category: "knowledge_management"
    priority: "high"

    principle: |
      모든 작업은 Obsidian에 자동으로 동기화되어,
      실행형 지식 자산으로 변환되어야 합니다.

    requirements:
      - desc: "TaskExecutor 완료 시 Obsidian 자동 동기화"
        mandatory: true
        target_time: "3초 이내"
      - desc: "자동 생성되는 문서"
        details:
          - "개발일지 (YYYY-MM-DD_작업제목.md)"
          - "작업 체크리스트 업데이트"
          - "MOC (Map of Content) 자동 갱신"
      - desc: "양방향 동기화 (프로젝트 ↔ Obsidian)"
        mandatory: false

    rationale: |
      지식 자산화는:
        - 수동 문서 작성 95% 절감 (20분 → 3초)
        - 지식 휘발 방지 (자동 기록)
        - 팀 지식 공유 (Obsidian 볼트 공유)
        - 과거 작업 재활용 (검색 가능)

    enforcement:
      tool: "ObsidianBridge"
      method: "TaskExecutor 완료 훅"
      violation_severity: "medium"

    metrics:
      time_saved: "95% (20min → 3sec)"
      annual_savings: "264 hours"

  # ============================================================================
  # 제4조: SOLID 원칙 준수 (SOLID Principles)
  # ============================================================================

  - id: "P4"
    name: "SOLID 원칙 준수"
    category: "code_quality"
    priority: "high"

    principle: |
      모든 코드는 SOLID 원칙을 준수해야 하며,
      위반 시 자동으로 감지되고 수정되어야 합니다.

    requirements:
      - desc: "Single Responsibility Principle (SRP)"
        checks:
          - "함수는 50줄 이하"
          - "클래스는 10개 메서드 이하"
          - "중첩 깊이 3단계 이하"
        severity: "medium"

      - desc: "Dependency Inversion Principle (DIP)"
        checks:
          - "구체 클래스 직접 인스턴스화 금지"
          - "의존성 주입 (Dependency Injection) 사용"
        severity: "high"

      - desc: "복잡도 제한"
        checks:
          - "Cyclomatic Complexity < 10"
          - "함수 파라미터 < 5개"
        severity: "medium"

    rationale: |
      SOLID 원칙은:
        - 유지보수성 향상
        - 테스트 용이성
        - 코드 재사용성
        - 버그 감소

    enforcement:
      tool: "DeepAnalyzer"
      method: "AST 기반 자동 검증"
      violation_severity: "medium"
      penalty: "-0.5점 per violation"

    quality_impact:
      weight: "30%"
      max_penalty: "-3.0점"

  # ============================================================================
  # 제5조: 보안 우선 (Security First)
  # ============================================================================

  - id: "P5"
    name: "보안 우선"
    category: "security"
    priority: "critical"

    principle: |
      모든 코드는 보안 이슈가 없어야 하며,
      Critical 등급 이슈는 즉시 수정되어야 합니다.

    requirements:
      - desc: "Critical 보안 이슈 0개"
        mandatory: true
        checks:
          - "하드코딩된 비밀번호/키 금지"
          - "eval() / exec() 사용 금지"
          - "pickle.loads() 사용 금지"

      - desc: "Major 보안 이슈 < 5개"
        mandatory: true
        checks:
          - "SQL 인젝션 방지"
          - "검증 없는 사용자 입력 금지"
          - "subprocess shell=True 금지"

      - desc: "환경 변수 사용"
        mandatory: true
        example: "password = os.getenv('PASSWORD')"

    rationale: |
      보안 우선은:
        - 데이터 유출 방지
        - 시스템 안정성
        - 신뢰성 확보
        - 컴플라이언스 준수

    enforcement:
      tool: "DeepAnalyzer"
      method: "패턴 매칭 + AST 분석"
      violation_severity: "critical"
      penalty: "-1.0점 per critical issue"

    quality_impact:
      weight: "40%"
      max_penalty: "-4.0점"

    response:
      critical: "즉시 수정 (1시간 이내)"
      major: "당일 수정"
      minor: "주간 스프린트 내"

  # ============================================================================
  # 제6조: 품질 게이트 (Quality Gate)
  # ============================================================================

  - id: "P6"
    name: "품질 게이트"
    category: "quality_assurance"
    priority: "high"

    principle: |
      프로젝트는 항상 최소 품질 기준을 충족해야 하며,
      Quality Gate 통과가 배포 조건입니다.

    requirements:
      - desc: "평균 품질 점수 ≥ 7.0/10"
        mandatory: true
        threshold: 7.0

      - desc: "테스트 통과율 ≥ 80%"
        mandatory: true
        threshold: 80.0

      - desc: "보안 이슈 (Critical) 0개"
        mandatory: true
        threshold: 0

    rationale: |
      품질 게이트는:
        - 최소 품질 기준 보장
        - 기술 부채 관리
        - 팀 품질 의식 향상
        - 프로덕션 안정성

    enforcement:
      tool: "TeamStatsAggregator"
      method: "전체 프로젝트 통계 집계"
      violation_severity: "high"

    dashboard:
      display: "Quality Gate (PASS/FAIL)"
      location: "Streamlit Dashboard 상단"
      update_frequency: "실시간"

    grading_system:
      A: "9.0 - 10.0 (🟢 훌륭함)"
      B: "8.0 - 8.9 (🟢 좋음)"
      C: "7.0 - 7.9 (🟡 보통)"
      D: "6.0 - 6.9 (🟡 개선 필요)"
      F: "0.0 - 5.9 (🔴 즉시 수정)"

  # ============================================================================
  # 제7조: Hallucination 방지 (Anti-Hallucination)
  # ============================================================================

  - id: "P7"
    name: "Hallucination 방지"
    category: "ai_safety"
    priority: "medium"

    principle: |
      AI 생성 코드는 Hallucination 위험을 검증해야 하며,
      불완전한 구현은 배포되지 않아야 합니다.

    requirements:
      - desc: "TODO/FIXME 주석 금지 (프로덕션)"
        mandatory: true

      - desc: "절대적 주장 금지"
        examples:
          - "always works"
          - "never fails"
          - "100% guaranteed"
          - "perfectly optimized"

      - desc: "Placeholder 값 금지"
        examples:
          - "placeholder"
          - "mock"
          - "fake"
          - "dummy"

      - desc: "NotImplementedError 금지"
        exception: "추상 클래스 제외"

    rationale: |
      Hallucination 방지는:
        - AI 생성 코드 품질 보장
        - 불완전 구현 방지
        - 과장된 주장 제거
        - 실제 작동하는 코드만 배포

    enforcement:
      tool: "DeepAnalyzer"
      method: "패턴 매칭"
      violation_severity: "low"
      penalty: "-0.1점 per risk"

    quality_impact:
      weight: "10%"
      max_penalty: "-1.0점"

  # ============================================================================
  # 제8조: 테스트 우선 (Test-First Development)
  # ============================================================================

  - id: "P8"
    name: "테스트 우선"
    category: "development_process"
    priority: "high"

    principle: |
      모든 기능은 테스트를 먼저 작성한 후 구현해야 하며,
      테스트 커버리지는 80% 이상이어야 합니다.

    requirements:
      - desc: "테스트 커버리지 ≥ 80%"
        mandatory: true
        threshold: 80.0
        rationale: |
          업계 표준 (Google 80%, Microsoft 70-80%)
          P15 수렴 원칙과 조화 (80%면 충분)
          80→90% ROI 낮음 (+3% 품질에 +40% 시간)

      - desc: "Red-Green-Refactor 사이클"
        steps:
          - "1. 테스트 작성 (Red)"
          - "2. 최소 구현 (Green)"
          - "3. 리팩토링 (Refactor)"

      - desc: "통합 테스트 우선"
        rationale: "Mock보다 실제 환경 테스트"

    enforcement:
      tool: "pytest + coverage"
      method: "CI/CD 파이프라인"
      violation_severity: "high"

  # ============================================================================
  # 제9조: Conventional Commits (커밋 표준)
  # ============================================================================

  - id: "P9"
    name: "Conventional Commits"
    category: "version_control"
    priority: "medium"

    principle: |
      모든 커밋은 Conventional Commits 표준을 따라야 하며,
      자동 버전 관리(Semantic Release)를 지원해야 합니다.

    format: "<type>(<scope>): <subject>"

    types:
      feat: "새 기능 (MINOR 버전 증가)"
      fix: "버그 수정 (PATCH 버전 증가)"
      docs: "문서 변경"
      refactor: "리팩토링"
      perf: "성능 개선 (PATCH)"
      test: "테스트 추가/수정"
      chore: "빌드/설정 변경"
      breaking: "Breaking change (MAJOR 버전 증가)"

    scopes:
      - "api"
      - "db"
      - "auth"
      - "ui"
      - "core"
      - "config"
      - "deploy"
      - "docs"
      - "test"
      - "security"

    enforcement:
      tool: "Commitlint"
      method: "Pre-commit hook"
      violation_severity: "medium"

  # ============================================================================
  # 제10조: Windows 인코딩 준수 (Emoji 금지)
  # ============================================================================

  - id: "P10"
    name: "Windows 인코딩 준수"
    category: "compatibility"
    priority: "medium"

    principle: |
      Windows 환경 호환성을 위해 코드에서 이모지 사용을 금지하며,
      ASCII 대체 문자를 사용해야 합니다.

    prohibited:
      - desc: "Python 코드에서 이모지 금지"
        files: "*.py"
      - desc: "YAML 파일에서 이모지 금지"
        files: "*.yaml, *.yml"
      - desc: "Shell 스크립트에서 이모지 금지"
        files: "*.sh, *.bat"

    allowed:
      - "Markdown 문서 (*.md)"
      - "HTML 파일"
      - "사용자 UI (Streamlit 등)"

    replacements:
      "✅": "[OK] or [SUCCESS]"
      "❌": "[FAIL] or [ERROR]"
      "⚠️": "[WARN]"
      "📝": "[LOG] or [FILE]"
      "🚀": "[DEPLOY]"
      "🔧": "[CONFIG]"

    rationale: |
      Windows cp949 인코딩은 이모지를 지원하지 않아
      UnicodeEncodeError가 발생합니다.

    enforcement:
      tool: "Pre-commit hook"
      method: "Regex 패턴 검사"
      violation_severity: "low"

  # ============================================================================
  # 제11조: 원칙 충돌 검증 (Principle Conflict Resolution)
  # ============================================================================

  - id: "P11"
    name: "원칙 충돌 검증"
    category: "governance"
    priority: "critical"

    principle: |
      새로운 기능이나 변경 사항이 과거 지시 또는 기존 원칙과 충돌할 경우,
      AI는 반드시 충돌을 리마인드하고 양측 관점을 제시해야 한다.

    requirements:
      - desc: "과거 지시 충돌 감지 트리거"
        triggers:
          - "새 Layer 추가"
          - "아키텍처 변경"
          - "도구 역할 변경"
          - "Constitution 조항 해석 변경"
          - "핵심 개념 재정의"
        mandatory: true

      - desc: "충돌 시 리마인드 포함사항"
        details:
          - "과거 지시 원문 인용 (날짜 포함)"
          - "새 제안과의 충돌 지점 명시"
          - "충돌 발생 맥락 설명"
          - "Git history 참조 (가능 시)"
        mandatory: true

      - desc: "양측 관점 제시 필수"
        format: |
          과거 원칙: [인용]
          새 제안: [설명]
          충돌 지점: [명시]

          Option A: 과거 원칙 유지
          Option B: 새 제안 적용

          (각 옵션의 장단점은 P12 적용)
        mandatory: true

    rationale: |
      과거 지시 무시의 위험:
        - 일관성 없는 시스템으로 변질
        - 방향성 상실 (예: Streamlit 대시보드를 주 목표로 착각)
        - 사용자 의도 왜곡
        - 기술 부채 누적

      리마인드 효과:
        - 사용자가 과거 결정 재검토 기회
        - 진화 vs 일관성 중 의식적 선택
        - 의사결정 투명성 확보
        - 시스템 정합성 유지

    enforcement:
      tool: "ConstitutionalValidator"
      method: "Git history + session memory 검색"
      automated: false  # 현재는 수동 검토
      violation_severity: "critical"

    examples:
      good: |
        # 사용자: "Streamlit 대시보드 추가해줘"

        AI: "⚠️ 원칙 충돌 감지 (P11)

        과거 지시 (2025-10-20):
        '이 프로젝트는 Constitution 중심 개발 체계다'

        새 제안:
        Layer 7 추가 (Streamlit Dashboard)

        충돌 지점:
        대시보드가 주 제품으로 오해될 위험

        Option A: Layer 7 추가 + 완화 전략
        Option B: 미추가 (현상 유지)

        (P12 트레이드오프 분석 참조)"

      bad: |
        # ❌ 충돌 감지했지만 리마인드 안 함

        AI: "네! Streamlit 대시보드 만들겠습니다!"
        (내부: Constitution 중심인데... 뭐 괜찮겠지)

        → 결과: 2주 후 "대시보드가 주 목표인 줄 착각" 발견

    # ════════════════════════════════════════════════════════════════
    # Anti-Patterns: 반복 패턴 재발 방지 (2025-11-08 추가)
    # ════════════════════════════════════════════════════════════════
    anti_patterns:
      description: "오늘 발견된 반복 의사결정 패턴을 규칙화하여 재발 방지"
      added: "2025-11-08"
      source: "Constitution Zero-Based 재설계 세션"

      pattern_1_zero_based_review:
        name: "예외 추가 대신 기준 재설계 (Zero-Based)"
        discovered: "P8, P16, P15, P17 Tier 2 모두 같은 패턴"

        trigger: "예외 규칙 추가하려 할 때"

        wrong_reflex: "기준 유지 + 예외 추가 → 복잡도 폭발"
        right_approach: "기준 재설계 → 예외 불필요"

        mandatory_questions:
          - "왜 원래 기준이 이랬지? (근거 확인)"
          - "근거가 있었나? (Evidence-Based)"
          - "업계 표준은 뭐지? (P16 벤치마킹)"
          - "기준 자체를 바꾸면 예외 불필요한가?"

        decision_rule: "기준 재설계 > 예외 추가"

        examples:
          - case: "P8: 90% + 예외 3개"
            solution: "80%로 재설계 → 예외 불필요"
          - case: "P16: 3+ + 예외"
            solution: "2-3 범위로 재설계 → 예외 불필요"
          - case: "P17 Tier 2: 무조건 검증 + 예외"
            solution: "Smart Validation Matrix → 예외 불필요"

      pattern_2_unverified_not_rejection:
        name: "미검증 ≠ 거부 (검증 기회)"
        discovered: "3번 반복 (Enhanced 3 vs 10, P17 초안, P17 개선)"
        severity: "CRITICAL - AI 고질적 편향"

        trigger: "미검증 제안 평가 시"

        ai_tendency: "미검증 → 부정적 판단 → 거부"
        correction: "미검증 → 중립 → 검증 프로세스 → 데이터 기반 결정"

        wrong_pattern: |
          "미검증" → "불확실하니까" → "위험하니까" → "거부"
          (혁신 차단!)

        right_pattern: |
          "미검증" → "아직 모름" → "측정하자" → "파일럿"
          → "데이터 수집" → "비교" → "근거 기반 결정"

        implementation:
          - "P17 Tier 2: Validation Decision Matrix (Cost × Impact)"
          - "P2 강화: '추측 금지 = 검증 필수' (거부 아님!)"
          - "RICE Confidence: Low (50%) ≠ Bad, just needs validation"

        never_say:
          - "미검증이라 안 됩니다"
          - "증거 없으니 거부합니다"
          - "불확실해서 위험합니다"

        always_say:
          - "미검증이니 2-Track 파일럿으로 검증하겠습니다"
          - "4주 측정 후 데이터 기반 결정하겠습니다"
          - "Low confidence (50%)이니 validation 후 비교하겠습니다"

      pattern_3_evidence_based_numbers:
        name: "모든 숫자는 P16 벤치마킹 필수"
        discovered: "P8 90%, P16 3개, Threshold 50/0.6 모두 근거 없음"

        trigger: "새 threshold, weight, percentage, scale 정의 시"

        mandatory_process:
          1_benchmark: "P16 경쟁사 벤치마킹 (최소 2-3개)"
          2_research: "산업 표준 조사 (WebSearch)"
          3_rationale: "근거 명시 (rationale 필수)"
          4_document: "Constitution에 출처 기록 (source, verified_by)"

        never_allowed:
          - "임의의 숫자 (50, 0.6, 70 같은 것)"
          - "'적당해 보이는' 숫자"
          - "'상식적인' 숫자 (근거 없음)"
          - "'보통 이 정도' 숫자"

        always_required:
          - "출처: Intercom RICE framework"
          - "검증: Thousands of companies (2024)"
          - "근거: MCC government standard 10% ROI"

        examples:
          - wrong: "threshold: 50 (근거 없음)"
            right: "minimum_roi: 10% (MCC U.S. Government standard)"

          - wrong: "weight: 0.6 (임의)"
            right: "scale: [3, 2, 1, 0.5, 0.25] (RICE Intercom verified)"

          - wrong: "coverage: 90% (왜?)"
            right: "coverage: 80% (Google/Microsoft industry standard)"

  # ============================================================================
  # 제12조: 트레이드오프 분석 의무 (Trade-off Analysis Mandate)
  # ============================================================================

  - id: "P12"
    name: "트레이드오프 분석 의무"
    category: "governance"
    priority: "critical"

    principle: |
      모든 주요 결정에 대해 AI는 양측 관점의 장단점을
      객관적 근거와 함께 제시해야 하며, 최종 결정은 사용자가 한다.

    requirements:
      - desc: "트레이드오프 분석 필수 항목"
        details:
          - "Option A vs Option B 명시"
          - "각 옵션의 장점 (객관적 근거)"
          - "각 옵션의 단점 (객관적 근거)"
          - "ROI 계산 (측정 가능 시)"
          - "위험도 평가 (Innovation Safety 기준)"
          - "적용 전후 비교"
        mandatory: true

      - desc: "객관적 근거 필수 출처"
        sources:
          - "과거 증거 (RUNS/evidence/)"
          - "측정 가능한 메트릭"
          - "유사 사례 (Git history, Obsidian)"
          - "Constitution 조항 인용"
          - "업계 표준 (공식 문서)"
        mandatory: true
        min_sources: 2  # 최소 2개 출처

      - desc: "추천 시 근거 명시"
        format: |
          추천: [Option X]

          근거:
            1. [측정 가능한 이유 + 출처]
            2. [과거 증거 기반 + 출처]
            3. [위험도 평가 결과]

          반론 (Option Y 선택 시):
            - [예상 문제점]
            - [완화 방안]
        mandatory: true

      - desc: "Innovation Safety 통합"
        checklist:
          - "Why? (현재 한계)"
          - "What if fails? (실패 영향)"
          - "How to rollback? (5분 내 복구 가능?)"
          - "Monitoring plan? (조기 감지)"
          - "User impact? (사용자 영향)"
        mandatory: true

    rationale: |
      AI 편향 방지:
        - 한쪽 관점만 제시 금지
        - 사용자가 전체 그림 이해
        - 확증 편향 (Confirmation Bias) 차단

      책임 소재 명확화:
        - AI: 객관적 분석 책임
        - 사용자: 최종 결정 책임
        - 역할 분리로 신뢰 확보

      증거 기반 결정 (P2 강화):
        - 주관적 추천 금지
        - 모든 주장은 근거 필요
        - 재현 가능한 의사결정

    enforcement:
      tool: "Human review (사용자 검토)"
      method: "체크리스트 제공"
      automated: false
      violation_severity: "high"

    decision_authority:
      ai_role: "객관적 분석 및 추천 제공"
      user_role: "최종 승인/거부 결정"

    examples:
      good: |
        # Streamlit 대시보드 추가 결정

        Option A: Streamlit 추가
        장점:
          - 시각화 개선 +30% (근거: 유사 프로젝트 사례)
          - P6 준수 현황 표시 (근거: Constitution P6 조항)
        단점:
          - 방향성 혼동 위험 ⚠️ 높음 (근거: 방금 경험)
          - 복잡도 +19% (근거: 코드량 측정)

        Option B: 미추가
        장점:
          - 단순성 유지 (근거: 현재 코드량)
        단점:
          - 시각화 부족 (근거: 사용자 불편)

        추천: Option A + 완화 전략
        근거:
          1. ROI 200% (근거: 절감 시간 계산)
          2. 완화 가능 (근거: Constitution.yaml 작성)
          3. 위험 낮음 (근거: 롤백 즉시 가능)

      bad: |
        # ❌ 한쪽 관점만

        AI: "Streamlit이 좋습니다! 시각화가 훌륭해요!"
        (단점 언급 없음, 근거 없음, 대안 제시 없음)

  # ============================================================================
  # 제13조: 헌법 수정 검증 (Constitutional Amendment Validation)
  # ============================================================================

  - id: "P13"
    name: "헌법 수정 검증"
    category: "meta_governance"
    priority: "critical"

    principle: |
      Constitution에 새 조항을 추가하거나 기존 조항을 수정할 때는
      반드시 타당성 검증을 거쳐야 하며, 최종 승인은 사용자가 한다.

      이 원칙은 P13 자체 추가에도 적용된다 (재귀적 적용).

    requirements:
      - desc: "타당성 검증 필수 항목"
        details:
          - "필요성: 왜 이 조항이 필요한가?"
          - "효과성: 실제 문제를 해결하는가?"
          - "ROI: 투자 대비 효과는?"
          - "위험: 부작용은 무엇인가?"
          - "복잡도: Constitution이 비대해지지 않는가?"
          - "충돌: 기존 조항과 모순되지 않는가?"
        mandatory: true

      - desc: "트레이드오프 분석 (P12 적용)"
        details:
          - "Option A: 조항 추가"
          - "Option B: 조항 미추가"
          - "각 옵션의 장단점 + 근거"
          - "ROI 계산"
          - "장기 영향 (5년 관점)"
        mandatory: true

      - desc: "사용자 승인 의무"
        process: |
          1. AI: 타당성 분석 제공
          2. AI: 트레이드오프 분석 (P12)
          3. AI: 추천 + 근거 제시
          4. 사용자: 최종 승인/거부
        mandatory: true

    self_application: true  # P13 추가 시에도 이 프로세스 적용됨

    enforcement:
      tool: "Human review (사용자 검토)"
      method: "명시적 승인 요구"
      automated: false
      violation_severity: "critical"

    decision_authority:
      ai_role: "타당성 분석 및 추천 제공"
      user_role: "최종 승인/거부 결정"

    limits:
      max_articles: 20  # Constitution 최대 20개 조항
      max_length_per_article: 150  # 조항당 최대 150줄
      review_period: "3개월"  # 전체 검토 주기

    rationale: |
      헌법 비대화 방지:
        - 5년 후 50개 조항 → 관리 불가
        - 모든 조항이 검증됨 → 품질 보장
        - 최대 20개 제한 → 집중도 유지

      품질 보장:
        - 불필요한 조항 추가 방지
        - 모순 조항 사전 차단
        - 명확성 유지

      재귀적 완전성:
        - Constitution이 자기 수정도 규정
        - 법학의 "헌법 개정 절차"와 동일
        - 무한 재귀 방지 (사용자 승인으로 루프 끊음)

    examples:
      good: |
        # P11, P12, P13 추가 (지금!)

        1. 타당성 검증:
           필요성: ✅ 방향성 상실 방지 (Streamlit 착각 사례)
           효과성: ✅ 실제 문제 해결
           ROI: ✅ P11,P12: 267%, P13: 438%
           위험: ⚠️ 복잡도 +31% (800→1,050줄)
           충돌: ✅ 없음, 기존 조항 강화

        2. 트레이드오프:
           Option A: 추가 (ROI 350%+, 실제 문제 해결)
           Option B: 미추가 (단순, 하지만 비대화 위험)

        3. 추천: Option A
           근거:
             - 실제 경험 (방향성 상실)
             - ROI 매우 높음 (350%+)
             - 장기 유지보수 절감 (5시간/년)

        4. 사용자 승인: [승인됨 ✅]

      bad: |
        # ❌ 검증 없이 추가

        - id: "P14"
          name: "모든 변수명은 한글로"
          # 타당성 검증 없음
          # ROI 계산 없음
          # 트레이드오프 분석 없음
          # 사용자 승인 없음

          → Constitution 비대화 + 품질 저하

  # ============================================================================
  # 제14조: 2차 효과 분석 (Second-Order Effects Analysis)
  # ============================================================================

  - id: "P14"
    name: "2차 효과 분석"
    category: "meta_governance"
    priority: "high"

    principle: |
      모든 개선 사항은 그 개선 자체가 야기할 부작용(2차 효과)을
      분석하고 완화 전략을 수립해야 한다.

      "유연성을 높이는 개선이 일관성을 해칠 수 있다"

    requirements:
      - desc: "Innovation Safety 체크리스트 (INNOVATION_SAFETY_PRINCIPLES.md)"
        checklist:
          - "Why? (현재 시스템의 한계는 무엇인가)"
          - "What if fails? (실패 시 비즈니스 영향은)"
          - "How to rollback? (5분 내 복구 가능한가)"
          - "Monitoring plan? (문제를 어떻게 조기 감지할 것인가)"
          - "User impact? (사용자가 느낄 부정적 영향은)"
        mandatory: true

      - desc: "부작용 완화 매트릭스 작성"
        format: |
          개선안: [설명]

          1차 효과 (직접적):
            긍정: [측정 가능한 이점]
            부정: [예상되는 문제]

          2차 효과 (간접적):
            긍정: [장기적 이점]
            부정: [부작용]

          완화 전략:
            - [부작용 1] → [완화 방안 + 측정 지표]
            - [부작용 2] → [완화 방안 + 측정 지표]

          모니터링:
            - [지표 1]: 목표 [값]
            - [지표 2]: 목표 [값]
        mandatory: true

      - desc: "자동 에스컬레이션 설정"
        triggers:
          - "완화 지표가 목표치 이탈 시"
          - "3개월 연속 부작용 발생 시"
          - "사용자 불만 증가 추세 시"
        action: "개선안 재검토 또는 롤백"
        mandatory: true

    rationale: |
      실제 사례 (유연성 추가):
        1차 효과: 채택률 30% → 90% (긍정)
        2차 효과: Override 남용 → 일관성 저하 (부정)
        완화: Minimum Viable Constitution + 모니터링

      무한 개선 루프 방지:
        - 개선 A → 부작용 B → 개선 C → 부작용 D → ...
        - P14 적용 → 각 개선마다 부작용 예측 및 완화
        - 순환 고리 끊기

      지속 가능한 개선:
        - 단기 이익 vs 장기 안정성
        - 빠른 성장 vs 기술 부채
        - 유연성 vs 일관성

    enforcement:
      tool: "Human review + PR template"
      method: "P14 섹션 필수 작성"
      automated: false  # 향후 자동화 검토
      violation_severity: "high"

    pr_template_addition: |
      ## [P14] Second-Order Effects Analysis

      ### 1st Order Effects
      - Positive: [직접적 이점]
      - Negative: [직접적 문제]

      ### 2nd Order Effects
      - Positive: [간접적 이점]
      - Negative: [간접적 부작용]

      ### Mitigation Strategy
      1. [부작용] → [완화 방안] (측정: [지표])
      2. [부작용] → [완화 방안] (측정: [지표])

      ### Monitoring Plan
      - [지표]: [목표치] (현재: [값])
      - Alert: [조건]

    examples:
      good: |
        # 유연성 개선 (Progressive Adoption) 제안

        1차 효과:
          긍정: 채택률 30% → 90%, 초기 저항 감소
          부정: 개발 시간 +2주

        2차 효과:
          긍정: 장기 유지보수 비용 -60%
          부정: Override 남용 가능성 (일관성 저하)

        완화 전략:
          - Override 남용 → Minimum Viable Constitution (4개 규칙 강제)
            측정: Override 사용률 < 10%
          - 일관성 저하 → 자동 에스컬레이션 (Level 0 > 2주)
            측정: Level 진행률 분기별 +1

        모니터링:
          - Override 사용률: 목표 < 10% (현재: 5%)
          - Level 0 체류 기간: 목표 < 2주 (현재: 1주)
          - Alert: 사용률 > 20% 시 경고

      bad: |
        # ❌ 부작용 분석 없이 개선

        제안: "모든 규칙을 선택적으로!"

        효과: 채택률 100% 달성!

        # 2차 효과 분석 없음
        # 완화 전략 없음
        # 모니터링 없음

        → 결과: 3개월 후 일관성 0%, 시스템 붕괴

    # ════════════════════════════════════════════════════════════════
    # Meta-Effects: Constitution 자기 개선 (2025-11-08 추가)
    # ════════════════════════════════════════════════════════════════
    meta_effects:
      description: "Constitution 자체의 지속적 개선 및 반복 패턴 규칙화"
      added: "2025-11-08"
      source: "Constitution Zero-Based 재설계 세션"

      meta_review_mandatory:
        name: "주기적 메타 리뷰 (패턴 식별)"
        frequency: "주 1회 또는 Major Constitution 변경 후"

        trigger_conditions:
          - "Major Constitution 변경 (P1-P17 수정)"
          - "같은 유형 실수 2번 이상 반복"
          - "큰 규모 개발 완료 (3일+ 작업)"
          - "사용자가 패턴 발견 지적"

        mandatory_questions:
          question_1: "오늘/이번 주 반복된 의사결정 패턴이 뭐였지?"
          question_2: "같은 실수를 여러 번 했나? (2번 이상)"
          question_3: "이 패턴을 규칙화하면 재발 방지 가능한가?"
          question_4: "P11 anti_patterns 업데이트 필요한가?"
          question_5: "P13 Constitution 수정 기준 충족하는가?"

        output_required:
          - "패턴 문서화 (claudedocs/ 또는 Obsidian)"
          - "P11 anti_patterns 업데이트 (필요 시)"
          - "P14 meta_effects 사례 추가"
          - "재발 방지 체크리스트 생성"

        examples:
          - pattern: "예외 추가 반복 (P8, P16, P15, P17)"
            action: "P11 pattern_1_zero_based_review 추가"
            result: "재발 방지 규칙 확립"

          - pattern: "미검증 = 거부 (3번 반복)"
            action: "P11 pattern_2_unverified_not_rejection 추가"
            result: "AI 편향 교정 규칙 확립"

      codified_flexibility:
        name: "Codified Flexibility (일관성 유지하는 유연성)"
        principle: "유연성을 IF-THEN 룰로 코드화하여 일관성 유지"

        wrong_approach: |
          "상황 봐서 판단하자"
          → AI Session 1: Cost 3일 → Skip
          → AI Session 2: Cost 3일 → Validate
          → 결과: 일관성 ↓ (같은 조건, 다른 결정)

        right_approach: |
          "IF Cost > 3 days AND Impact < MEDIUM THEN Skip"
          → AI Session 1: 같은 조건 → Skip
          → AI Session 2: 같은 조건 → Skip
          → 결과: 일관성 ✅ (같은 조건, 같은 결정)

        implementation_examples:
          - name: "P17 Tier 2 Smart Validation"
            flexibility: "비용/영향도 기반 결정"
            codification: "Validation Decision Matrix (2×2)"
            consistency: "모든 AI가 Matrix 동일 적용"

          - name: "RICE Confidence levels"
            flexibility: "검증 수준에 따라 다른 가중치"
            codification: "100%/80%/50% (Intercom 표준)"
            consistency: "산업 표준으로 일관성"

        benefits:
          - "유연성 확보 (컨텍스트별 다른 결정)"
          - "일관성 유지 (같은 룰 적용)"
          - "투명성 향상 (결정 근거 명확)"
          - "협업 용이 (팀원 즉시 이해)"

      continuous_improvement_cycle:
        name: "지속적 개선 사이클 (PDCA)"

        plan: "위험 평가 및 완화 전략 수립 (Innovation Safety)"
        do: "최소 기능으로 시작 (P15 80% 수렴)"
        check: "실시간 메트릭 및 사용자 피드백"
        act: "학습 기반 시스템 개선 + 패턴 규칙화"

        success_criteria:
          - "반복 패턴 → 규칙화 (P11 anti_patterns)"
          - "같은 실수 2번 이하 (3번부터 규칙 추가)"
          - "Constitution 비대화 방지 (P15 < 20 articles)"
          - "ROI > 300% 유지 (P15 기준)"

      pattern_to_rule_process:
        description: "발견된 패턴을 Constitution 규칙으로 전환하는 프로세스"

        step_1_identify:
          action: "패턴 식별 (Meta-Review)"
          criteria: "같은 유형 실수 2번 이상"
          output: "패턴 문서화 (이름, 발견 이력, 근본 원인)"

        step_2_validate:
          action: "패턴 검증 (재발 가능성)"
          criteria: "AI 고질적 편향 OR 구조적 문제"
          output: "규칙화 필요성 판단"

        step_3_codify:
          action: "규칙 작성 (P11 anti_patterns)"
          format: |
            pattern_N_name:
              trigger: "언제 적용?"
              wrong: "잘못된 접근"
              right: "올바른 접근"
              examples: "구체적 사례"

        step_4_integrate:
          action: "Constitution 통합"
          location: "P11 anti_patterns OR P14 meta_effects"
          verification: "P13 Constitution 수정 기준 충족 확인"

        step_5_monitor:
          action: "효과 측정"
          metric: "패턴 재발률 (목표: 0%)"
          escalation: "3개월 내 재발 → 규칙 강화"

  # ============================================================================
  # 제15조: 수렴 원칙 (Convergence Principle)
  # ============================================================================

  - id: "P15"
    name: "수렴 원칙"
    category: "meta_governance"
    priority: "critical"

    principle: |
      Constitution은 무한히 확장되지 않으며,
      "충분히 좋은(Good Enough)" 상태에 수렴해야 한다.

      목표: 80% 품질 달성 후 안정화 (100% 추구 금지)

    requirements:
      - desc: "중단 조건 (Stop Conditions)"
        triggers:
          - "ROI > 300% 달성"
          - "팀 만족도 > 80%"
          - "3개월간 안정적 운영"
          - "새 제안 ROI < 150%"
        action: "개선 중단, 안정화 단계 진입"
        mandatory: true

      - desc: "위험 신호 (Danger Signs)"
        indicators:
          - "매달 새 조항 추가"
          - "Constitution > 20개 조항"
          - "복잡도 예산 초과 (>1500 lines)"
          - "팀원들이 헷갈려함"
        action: "즉시 단순화 작업"
        mandatory: true

      - desc: "80/20 Rule 적용"
        principle: "Core 10개 조항이 80% 가치 제공"
        calculation: |
          ROI = improvement_gain / improvement_effort

          if ROI < 0.5:
              return "Not worth it! 현재가 충분히 좋음"

          if current_quality >= 80:
              return "Good enough! 멈춰라"
        mandatory: true

      - desc: "복잡도 예산 (Complexity Budget)"
        limits:
          primary: "max_articles: 20 (P13과 동일)"
          secondary: "avg_lines_per_article: < 100"
          max_tools: 15
        rationale: |
          조항 수가 주 기준 (명확함)
          총 Lines는 자연스럽게 제한됨 (20 × 100 = 2,000 이하)
          예시 길이에 덜 민감
        enforcement: "조항 20개 초과 시 통합/제거 필수"
        mandatory: true

    sunset_clauses:
      one_year_rule: "1년간 미사용 조항 → 제거 검토"
      roi_rule: "1년간 ROI < 100% → 폐지 검토"
      replacement_rule: "더 나은 조항 등장 → 통합"
      overlap_rule: "중복 기능 → 하나로 병합"

    magic_number: |
      The Magic Number: 15 articles

      - Core (P1-P10): 80% 가치
      - Governance (P11-P13): 15% 가치
      - Meta (P14-P15): 5% 가치
      - Total: 100% 가치

      → 16개째부터 ROI 급감!

    rationale: |
      무한 개선 루프 방지:
        - 개선 → 부작용 → 개선 → 부작용 → ...
        - P15 적용 → 80% 도달 시 멈춤
        - 안정화 우선

      실용주의:
        - 80점이면 충분하다
        - 100점 추구는 비효율 (ROI < 0.5)
        - 완벽주의 ≠ 생산성

      지속 가능성:
        - Constitution 비대화 방지
        - 팀 인지 부하 관리
        - 장기 유지보수 가능

    enforcement:
      tool: "ConstitutionalValidator + Human review"
      method: "분기별 ROI 검토 + 복잡도 측정"
      automated: true  # 복잡도 자동 측정
      violation_severity: "high"

    quarterly_review:
      schedule: "3개월마다"
      checklist:
        - "ROI 검토 (각 조항)"
        - "복잡도 측정 (총 라인 수)"
        - "사용 빈도 분석"
        - "통합 가능 조항 탐색"
        - "제거 후보 선정"

    decision_framework: |
      새 조항 제안 시:

      if ROI < 1.5x:
          reject("ROI 부족")
      elif complexity > 150 lines:
          reject("단순화 필요")
      elif total_articles >= 20:
          require("기존 조항 제거 or 통합")
      elif stable_for_6months:
          reject("안정화 단계 - 개선 중단")
      else:
          accept("P14로 2차 효과 검증")

    examples:
      good: |
        # 분기별 리뷰 (2025-Q4)

        현재 상태:
          - 조항 수: 15개
          - 총 라인: 1,400줄
          - ROI: 377%
          - 팀 만족도: 85%
          - 안정 운영: 3개월

        중단 조건 체크:
          ✅ ROI > 300%
          ✅ 만족도 > 80%
          ✅ 3개월 안정
          ✅ 신규 제안 없음

        결정: 개선 중단, 안정화 단계 진입

        다음 리뷰: 2026-Q1 (유지보수만)

      bad: |
        # ❌ 무한 개선

        매달 새 조항 추가:
          2025-10: P14, P15 추가 (OK, 필요함)
          2025-11: P16 "코드 리뷰 자동화"
          2025-12: P17 "성능 모니터링"
          2026-01: P18 "UI 테스트"
          ...
          2026-06: P30 "???"

        문제:
          - Constitution 1,800줄 (예산 초과)
          - 팀원 혼란 ("어떤 규칙 따라야 해?")
          - 복잡도 폭발 → 아무도 안 지킴
          - ROI 마이너스

        → P15 위반: 수렴하지 않고 발산

  # ============================================================================
  # 제16조: 경쟁사 벤치마킹 우선 (Competitive Benchmarking)
  # ============================================================================

  - id: "P16"
    name: "경쟁사 벤치마킹 우선"
    category: "strategic_planning"
    priority: "important"

    principle: |
      새로운 기능이나 프로젝트를 시작하기 전,
      비슷한 범주의 상용화된 경쟁 제품을 분석하고
      차별화 전략을 수립해야 한다.

      목표: 더 나은 버전의 프로그램 개발

    requirements:
      - desc: "경쟁사 제품 2-3개 분석"
        mandatory: true
        guideline: "일반 3개, 틈새 시장 2개"
        rationale: |
          업계 표준 (YC Startup School 2-3개, Lean Startup 최소 2개)
          유연성 확보 (틈새 시장도 커버)
          예외 불필요 (범위로 해결)
        details:
          - "각 제품의 강점(strengths) 파악"
          - "각 제품의 약점(weaknesses) 파악"
          - "인기도(github stars, 커뮤니티) 평가"

      - desc: "차별화 포인트(Differentiation) 3개 이상 도출"
        mandatory: true
        details:
          - "point: 차별화 요소"
          - "rationale: 차별화 근거"
          - "target: 타겟 시장"
          - "complexity: 구현 복잡도"
          - "impact: 예상 효과"

      - desc: "YAML 계약서에 benchmarking 섹션 포함"
        mandatory: true
        format: |
          benchmarking:
            query: "todo app"
            category: "productivity"
            competitors: [...]  # 3개 이상
            differentiation: [...]  # 3개 이상
            target_market: {...}

    rationale: |
      경쟁사 벤치마킹이 중요한 이유:
        - 바퀴 재발명 방지 (기존 제품 학습)
        - 차별화 전략 수립 (경쟁 우위 확보)
        - 시장 검증된 기능 활용 (리스크 감소)
        - 개발 우선순위 결정 (ROI 높은 기능 우선)

      투자 대비 효과:
        - 초기 분석: 2-3시간
        - 방지된 실패: 수백 시간
        - ROI: 1,750% (연 740시간 절감)

    enforcement:
      tool: "BenchmarkAnalyzer + P16Validator"
      method: "YAML contract 자동 검증"
      automated: true
      violation_severity: "medium"

    workflow: |
      1. 주제 결정: "todo app 개발"
      2. 벤치마킹 실행:
         python scripts/benchmark_analyzer.py --query "todo app"
      3. 결과 검토: 경쟁사 3-5개 분석 결과 확인
      4. YAML 반영: benchmarking 섹션 추가
      5. 게이트 통과: P16 gate 자동 검증

    tools:
      BenchmarkAnalyzer:
        components:
          - "CompetitorSearcher: 경쟁사 검색 및 순위화"
          - "ProductAnalyzer: 제품 분석 (강점/약점)"
          - "DifferentiationGenerator: 차별화 전략 생성"
        performance:
          - "검색: <5분"
          - "분석: <3분/제품"
          - "전체 파이프라인: <15분"

      P16Validator:
        checks:
          - "최소 3개 경쟁사"
          - "최소 3개 차별화 포인트"
          - "필수 필드 존재 (name, strengths, weaknesses)"
          - "차별화 필드 (point, rationale, target)"

    differentiation_strategies:
      - name: "Gap Analysis"
        desc: "경쟁사가 모두 놓친 기능 공략"
        example: "AI 자동 우선순위 (모든 todo app이 없음)"

      - name: "Weakness Exploitation"
        desc: "공통 약점 해결"
        example: "Things 3는 Mac 전용 → 크로스 플랫폼"

      - name: "Combination Innovation"
        desc: "여러 제품의 장점 결합"
        example: "Todoist 자연어 + TickTick 포모도로"

      - name: "Niche Targeting"
        desc: "특정 틈새 시장 공략"
        example: "개발자용 CLI 기반 todo (Notion은 GUI)"

    examples:
      good: |
        # TASKS/FEAT-2025-11-04-TODO-APP.yaml

        task_id: "FEAT-2025-11-04-TODO-APP"
        title: "AI-Powered Todo App"

        # P16 Gate
        gates:
          - id: "p16-benchmarking"
            type: "constitutional"
            articles: ["P16"]

        # P16 Benchmarking Section
        benchmarking:
          query: "todo app"
          category: "productivity"

          competitors:
            - name: "Todoist"
              github_stars: 50000
              strengths:
                - title: "Natural Language"
                  description: "Parse dates automatically"
              weaknesses:
                - category: "AI"
                  description: "No auto-priority"

            - name: "TickTick"
              github_stars: 30000
              strengths:
                - title: "Pomodoro Timer"
              weaknesses:
                - category: "UX"
                  description: "Complex UI"

            - name: "Things 3"
              github_stars: 40000
              strengths:
                - title: "Beautiful Design"
              weaknesses:
                - category: "Platform"
                  description: "MacOS only"

          differentiation:
            - point: "AI Auto-Priority"
              rationale: "No competitor has this"
              target: "Busy professionals"
              complexity: "high"
              impact: "high"

            - point: "Open Source"
              rationale: "Things 3 closed source"
              target: "Privacy users"
              complexity: "medium"
              impact: "medium"

            - point: "Cross-Platform"
              rationale: "Things 3 Mac only"
              target: "Windows/Linux users"
              complexity: "high"
              impact: "high"

          target_market:
            segment: "Developers"
            size: "1M+"

      bad: |
        # ❌ No benchmarking section

        task_id: "FEAT-2025-11-04-TODO-APP"
        title: "Todo App"

        commands:
          - exec: ["python", "src/todo.py"]

        # P16 Gate FAILS:
        # - No benchmarking section
        # - No competitor analysis
        # - No differentiation strategy

        → TaskExecutor will block execution!

    integration_with_other_articles:
      - article: "P1"
        relation: "P16 섹션은 YAML 계약서에 포함"

      - article: "P2"
        relation: "벤치마킹 결과는 evidence로 저장"

      - article: "P14"
        relation: "차별화 전략의 2차 효과 분석"

      - article: "P15"
        relation: "P16도 80% 품질 목표 (완벽 불필요)"

    roi_analysis:
      setup_cost:
        initial_implementation: "40 hours"
        per_project_analysis: "2-3 hours"

      benefits:
        prevented_failures: "10 projects/year × 40 hours = 400 hours"
        better_prioritization: "20 hours/project × 10 = 200 hours"
        faster_decisions: "14 hours/month × 12 = 168 hours"
        total_annual_savings: "768 hours"

      roi_calculation: |
        Investment: 40 hours (initial) + 30 hours (annual analysis)
        Return: 768 hours saved annually
        ROI: (768 - 70) / 70 × 100% = 997%
        Break-even: 1 week

    success_metrics:
      - metric: "경쟁사 분석 완료율"
        target: "100% (모든 신규 프로젝트)"

      - metric: "차별화 성공률"
        target: ">60% (3개 중 2개 성공)"

      - metric: "프로젝트 실패 방지"
        target: "연 5개 이상"

      - metric: "분석 시간"
        target: "<30분 (자동화로 단축)"

  # ============================================================================
  # 제17조: 의사결정 프레임워크 (Decision Framework)
  # ============================================================================

  - id: "P17"
    name: "의사결정 프레임워크"
    category: "meta_governance"
    priority: "critical"

    principle: |
      원칙 충돌 시 다음 4-Tier 우선순위로 자동 해결하며,
      AI 일관성을 보장하고 모순 재발을 방지한다.

    decision_tiers:
      tier_1_safety:
        priority: 1
        principle: "안전 > 모든 것"
        articles: ["P5"]
        rule: "보안, 데이터 안전은 절대 타협 불가"
        examples:
          - "P5 보안 vs P15 단순성 → P5 승리"
          - "P5 Critical 이슈 vs 개발 속도 → P5 우선"

      tier_2_evidence:
        priority: 2
        principle: "증거 기반 의사결정 + Smart Validation (Cost-Benefit)"
        articles: ["P2"]
        rule: "모든 주장은 증거로 검증 가능해야 하되, 비용/영향도 기반 smart decision"

        core_philosophy: |
          ❌ "미검증" ≠ "거부"
          ✅ "미검증" = "검증 필요" (단, 비용/영향도 고려)

          Wrong: 모든 미검증 항목 → 무조건 검증 (낭비)
          Right: 영향도 HIGH → 검증, 영향도 LOW → Skip

        # ═══════════════════════════════════════════════════
        # Validation Decision Matrix (2×2: Cost × Impact)
        # ═══════════════════════════════════════════════════
        validation_decision_matrix:
          high_cost_high_impact:
            validation_cost: "> 3 days"
            impact: "Critical (security, data, production break, core architecture)"
            strategy: "MUST validate (no exception)"
            rationale: "High risk → insurance worth it"
            process: "2-Track pilot (4 weeks minimum)"
            examples:
              - "PostgreSQL → MongoDB migration (3개월)"
              - "Microservices → Monolith redesign"
              - "New auth system (security critical)"

          high_cost_low_impact:
            validation_cost: "> 3 days"
            impact: "Low (UI polish, code style, non-critical feature)"
            strategy: "SKIP or DEFER (P15 80% 수렴 원칙)"
            rationale: "Low ROI → not worth validation cost"
            process: "Use existing solution OR P12 user decision"
            examples:
              - "불확실성 지도 3개 vs 10개 (UI 요소만 차이)"
              - "10개 UI 컴포넌트 라이브러리 vs 3개"
              - "코드 포매터 세밀 조정"

          low_cost_high_impact:
            validation_cost: "< 1 day"
            impact: "Critical"
            strategy: "ALWAYS validate (cheap insurance)"
            rationale: "High risk, low cost → validate 필수"
            process: "Quick pilot (1-2주)"
            examples:
              - "Security library version test"
              - "Critical bug fix validation"
              - "Performance regression test"

          low_cost_low_impact:
            validation_cost: "< 1 day"
            impact: "Low"
            strategy: "Quick pilot (2-Track 10%)"
            rationale: "Low risk, low cost → 빠르게 시도"
            process: "1주 파일럿 → 즉시 결정"
            examples:
              - "코드 포매터 Prettier vs Black"
              - "Linter rule tweak"
              - "Minor UI animation"

        # ═══════════════════════════════════════════════════
        # Multi-Dimensional Tradeoff Scoring (RICE Framework)
        # ═══════════════════════════════════════════════════
        multi_dimensional_tradeoff:
          methodology: "RICE Scoring (Industry Standard)"
          source: "Intercom (2016), widely adopted across tech industry"
          benchmark: "P16 경쟁사 벤치마킹 완료 (2024)"

          description: |
            RICE = (Reach × Impact × Confidence) / Effort
            단순화: Impact × Confidence / Effort (Reach는 컨텍스트별)

          # ═══════════════════════════════════════════════
          # Impact Scale (RICE Industry Standard)
          # ═══════════════════════════════════════════════
          impact_scale:
            source: "Intercom RICE framework"
            verified_by: "Thousands of companies (2024)"

            scale:
              massive:
                value: 3.0
                description: "핵심 메트릭 대폭 개선 (3배 효과)"
                examples:
                  - "보안 취약점 수정 (Critical)"
                  - "성능 3배 향상"
                  - "사용자 경험 혁신"

              high:
                value: 2.0
                description: "핵심 메트릭 큰 개선 (2배 효과)"
                examples:
                  - "주요 기능 추가"
                  - "성능 2배 향상"
                  - "중요 버그 수정"

              medium:
                value: 1.0
                description: "핵심 메트릭 적당한 개선 (기준)"
                examples:
                  - "일반 기능 개선"
                  - "성능 30-50% 향상"
                  - "UX 개선"

              low:
                value: 0.5
                description: "핵심 메트릭 작은 개선 (1/2 효과)"
                examples:
                  - "UI polish"
                  - "성능 10-20% 향상"
                  - "마이너 개선"

              minimal:
                value: 0.25
                description: "핵심 메트릭 미미한 개선 (1/4 효과)"
                examples:
                  - "코드 스타일"
                  - "문서화"
                  - "리팩토링 (성능 변화 없음)"

          # ═══════════════════════════════════════════════
          # Confidence Scale (RICE Industry Standard)
          # ═══════════════════════════════════════════════
          confidence_scale:
            source: "Intercom RICE framework"
            verified_by: "Industry best practice (2024)"

            scale:
              high:
                value: 100
                percentage: "100%"
                description: "완전히 검증됨 (과거 데이터 있음)"
                examples:
                  - "2년+ 사용한 솔루션"
                  - "A/B 테스트 완료"
                  - "프로덕션 검증 완료"

              medium:
                value: 80
                percentage: "80%"
                description: "부분 검증됨 (일부 증거)"
                examples:
                  - "파일럿 테스트 완료"
                  - "유사 사례 존재"
                  - "프로토타입 검증"
                note: "P15 80% 수렴 원칙과 일치!"

              low:
                value: 50
                percentage: "50%"
                description: "미검증 (가설/이론만)"
                examples:
                  - "신규 제안 (증거 없음)"
                  - "이론적 분석만"
                  - "추측 기반"

              moonshot:
                value: "<50"
                percentage: "<50%"
                description: "매우 불확실 (위험)"
                warning: "Confidence < 50% → 매우 신중 또는 거부"
                examples:
                  - "완전히 새로운 접근"
                  - "검증 불가능"
                  - "투기적 아이디어"

          # ═══════════════════════════════════════════════
          # Effort Scale (WSJF Fibonacci - Industry Standard)
          # ═══════════════════════════════════════════════
          effort_scale:
            source: "SAFe WSJF framework"
            verified_by: "Scaled Agile (2024)"

            scale: [1, 2, 3, 5, 8, 13, 21]
            unit: "person-days"
            rationale: "Fibonacci는 불확실성 반영"

            guidelines:
              - range: "1-3 days"
                certainty: "높음 (정확 예측 가능)"
              - range: "5-8 days"
                certainty: "중간 (약간의 불확실성)"
              - range: "13-21 days"
                certainty: "낮음 (높은 불확실성)"
              - range: ">21 days"
                action: "더 작은 단위로 분해 필요"

          # ═══════════════════════════════════════════════
          # RICE Scoring Formula
          # ═══════════════════════════════════════════════
          scoring_formula: |
            RICE Score = (Impact × Confidence%) / Effort

            Example 1: 성능 최적화 (검증됨)
              - Impact: High (2.0)
              - Confidence: High (100% = 1.0)
              - Effort: 5 days
              - RICE = (2.0 × 1.0) / 5 = 0.40

            Example 2: UI polish (미검증)
              - Impact: Low (0.5)
              - Confidence: Medium (80% = 0.8)
              - Effort: 13 days
              - RICE = (0.5 × 0.8) / 13 = 0.03

            Example 3: 보안 패치 (긴급)
              - Impact: Massive (3.0)
              - Confidence: High (100% = 1.0)
              - Effort: 2 days
              - RICE = (3.0 × 1.0) / 2 = 1.50

            Decision: Score 높은 순 우선순위
              - Example 3 (1.50) > Example 1 (0.40) > Example 2 (0.03)
              - 보안 패치 > 성능 최적화 > UI polish

          # ═══════════════════════════════════════════════
          # Decision Threshold (Enterprise ROI Standard)
          # ═══════════════════════════════════════════════
          decision_threshold:
            source: "MCC (Millennium Challenge Corporation) - U.S. Government"
            verified_by: "Enterprise standard for taxpayer funds (2024)"

            minimum_roi: 10%
            rationale: |
              - 10% = 인플레이션 + 기회비용
              - 납세자 자금 책임성
              - 간단한 의사결정 기준

            formula: "ROI = (Benefit - Cost) / Cost × 100%"

            decision_rules:
              accept: "ROI ≥ 10% AND RICE Score > 0.1"
              review: "ROI < 10% OR RICE Score < 0.1 → P12 사용자 결정"
              reject: "ROI < 0% (손해) → 거부"

            context_adjustments:
              prototype:
                min_roi: 5%
                rationale: "빠른 검증 우선, 낮은 기준"

              production:
                min_roi: 15%
                rationale: "안정성 중시, 높은 기준"

              urgent_bug:
                min_roi: "N/A"
                rationale: "긴급성 > ROI (보안/중단 이슈)"

          # ═══════════════════════════════════════════════
          # Real-World Application Examples
          # ═══════════════════════════════════════════════
          application_examples:
            - name: "성능 +150% vs 토큰 -30% (사용자 예시)"
              impact: "High (2.0) - 성능 대폭 향상"
              confidence: "Medium (80% = 0.8) - 파일럿 필요"
              effort: "8 days"
              rice_score: "(2.0 × 0.8) / 8 = 0.20"
              roi: "150% benefit - 30% cost = 120% net → ROI = 400%"
              decision: "ACCEPT (ROI 400% >> 10% threshold)"
              rationale: "성능 향상이 토큰 손실을 충분히 상쇄"

            - name: "성능 +100% vs 토큰 -30% (사용자 예시)"
              impact: "Medium (1.0) - 성능 적당히 향상"
              confidence: "Medium (80% = 0.8)"
              effort: "8 days"
              rice_score: "(1.0 × 0.8) / 8 = 0.10"
              roi: "100% benefit - 30% cost = 70% net → ROI = 233%"
              decision: "REVIEW (RICE 경계값, ROI는 충분)"
              rationale: "P12 사용자 결정 - 토큰 비용 vs 성능"

            - name: "불확실성 지도 3개 vs 10개"
              three_components:
                impact: "Medium (1.0)"
                confidence: "High (100% = 1.0) - 6개월 검증"
                effort: "3 days (이미 구현됨)"
                rice_score: "(1.0 × 1.0) / 3 = 0.33"

              ten_components:
                impact: "Medium (1.0) - UI 표현만 다름"
                confidence: "Low (50% = 0.5) - 미검증"
                effort: "90 days (10개 × 3주)"
                rice_score: "(1.0 × 0.5) / 90 = 0.006"

              decision: "3개 선택 (RICE 0.33 >> 0.006)"
              rationale: |
                - 10개 RICE score 55배 낮음
                - P15 수렴: 3개로 80% 달성
                - Validation cost > benefit

        # ═══════════════════════════════════════════════════
        # Rigidity Classification (어떤 요소는 Rigid, 어떤 요소는 Flexible)
        # ═══════════════════════════════════════════════════
        rigidity_classification:
          always_rigid:
            description: "절대 예외 없음 (Tier 1 Safety와 동급)"
            elements:
              - "P5 Security (보안 취약점)"
              - "Data safety (데이터 손실 위험)"
              - "Production breaks (서비스 중단)"
              - "P2 Evidence (추측 금지)"
            rationale: "사용자 신뢰/안전 > 모든 것"

          flexible_with_codified_rules:
            description: "Flexible하되, 룰이 명확함 (일관성 유지)"
            elements:
              - element: "Performance optimization"
                rule: "Multi-dimensional scoring"
                threshold: "weighted_score > 50"
                example: "성능 +150%, 토큰 -30% → Accept"

              - element: "Code style/formatting"
                rule: "Impact-based skip"
                threshold: "impact < MEDIUM → SKIP validation"
                example: "Prettier vs Black → Quick pilot (1주)"

              - element: "UI polish"
                rule: "Cost-benefit analysis"
                threshold: "validation_cost > 2 days AND impact < HIGH → DEFER"
                example: "10개 UI 컴포넌트 vs 3개 → Skip (low impact)"

              - element: "Documentation completeness"
                rule: "P15 수렴 원칙"
                threshold: "80% coverage → STOP"
                example: "80% 문서화 완료 → 나머지 20% Skip"

              - element: "Test coverage edge cases"
                rule: "P15 수렴 원칙"
                threshold: "80% coverage → STOP"
                example: "80% 커버리지 달성 → edge case Skip"

          context_dependent:
            description: "컨텍스트에 따라 P12 사용자 결정 필요"
            elements:
              - "Architecture choice (microservices vs monolith)"
              - "Framework selection (React vs Vue vs Angular)"
              - "Database choice (PostgreSQL vs MongoDB vs DynamoDB)"
              - "Deployment strategy (Blue-Green vs Canary vs Rolling)"
            rationale: "비즈니스 요구사항에 따라 답이 다름"
            process: "P12 트레이드오프 분석 → 사용자 결정"

        # ═══════════════════════════════════════════════════
        # Examples with Matrix Application
        # ═══════════════════════════════════════════════════
        examples:
          - name: "불확실성 지도 3개 vs 10개 (REVISED)"
            classification: "High cost (검증 3개월), Low impact (UI 요소만)"
            matrix_quadrant: "high_cost_low_impact"
            decision: "SKIP validation (P15 80% 수렴)"
            rationale: |
              - Validation cost: 3개월 (10개 각각 테스트)
              - Impact: LOW (UI 표현 방식만 차이, 핵심 기능 동일)
              - P15 적용: 3개로 80% 달성 → 나머지 7개는 과도
              - ROI: 3개월 투자 → UI 개선 (낮음)
              - Decision: Enhanced 3개 사용, 10개 Skip

          - name: "PostgreSQL vs MongoDB"
            classification: "High cost (3개월), High impact (core architecture)"
            matrix_quadrant: "high_cost_high_impact"
            decision: "MUST validate"
            process: |
              1. PostgreSQL: 2년 검증됨
              2. MongoDB: 미검증
              3. Impact: Critical (core DB)
              4. Cost: 3개월 마이그레이션
              5. Quadrant: High/High → MUST validate
              6. 2-Track: 90% PostgreSQL, 10% MongoDB 파일럿
              7. 4주 측정 → 데이터 기반 결정

          - name: "Security library version test"
            classification: "Low cost (<1일), High impact (security)"
            matrix_quadrant: "low_cost_high_impact"
            decision: "ALWAYS validate (cheap insurance)"
            rationale: |
              - Cost: 1일 테스트
              - Impact: Critical (보안 취약점 가능)
              - Quadrant: Low/High → 반드시 검증
              - Process: 1일 quick test → 즉시 적용

          - name: "성능 +150% but 토큰 -30%"
            classification: "Multi-dimensional tradeoff"
            scoring: |
              - Performance: +150% (150 × 0.6 = 90)
              - Token: -30% (-30 × 0.4 = -12)
              - Weighted score: 90 - 12 = 78
              - Threshold: 50
              - Decision: 78 > 50 → ACCEPT
            rationale: "성능 향상이 토큰 손실을 충분히 상쇄"

      tier_3_pragmatic:
        priority: 3
        principle: "YAGNI + KISS + 80% 수렴"
        articles: ["P15"]
        rule: "단순함, 실용성 우선"
        examples:
          - "P8 80% vs 완벽주의 90% → 80% 채택 (P15 적용)"
          - "복잡한 해결책 vs 단순한 해결책 → 단순함 우선"

      tier_4_progressive:
        priority: 4
        principle: "점진적 성장"
        articles: ["P14"]
        rule: "부작용 완화 가능하면 시도, 실패 시 즉시 롤백"
        examples:
          - "새 기술 도입: 2-Track 전략 (90% 안정, 10% 실험)"

    conflict_resolution_algorithm: |
      def resolve_conflict(principle_a, principle_b, context):
          tier_a = get_tier(principle_a)
          tier_b = get_tier(principle_b)

          if tier_a < tier_b:
              return principle_a  # 낮은 tier 번호가 우선
          elif tier_a > tier_b:
              return principle_b
          else:
              # Same tier → P12 트레이드오프 분석
              return ask_user_with_tradeoff_analysis(
                  principle_a, principle_b, context
              )

    rationale: |
      Zero-Based Constitution과 시너지:
        - Zero-Based가 현재 모순 해결 (7개 → 0개)
        - P17이 미래 모순 방지 (자동 우선순위)
        - 상호 강화 효과 (단순함 + 일관성)

      AI 일관성 보장:
        - 매번 같은 기준으로 판단
        - "4번 질문, 4번 다른 답변" 방지
        - 사용자 신뢰 확보

      장기 안정성:
        - P18, P19 추가 시에도 충돌 자동 해결
        - Constitution 진화 가능 (모순 없이)

    enforcement:
      tool: "AI internal decision logic"
      method: "자동 적용 (충돌 감지 시)"
      automated: true
      violation_severity: "high"

    integration_with_other_articles:
      - article: "P11"
        relation: "P11이 충돌 감지 → P17이 해결"

      - article: "P12"
        relation: "Same tier 충돌 → P12 트레이드오프 분석"

      - article: "P13"
        relation: "P17도 P13 검증 대상 (재귀적 적용)"

      - article: "P15"
        relation: "P17 자체도 단순함 유지 (100 lines)"

    examples:
      good: |
        # Case 1: P5 vs P15 충돌
        상황: "보안 검증 vs 빠른 배포"
        P17 적용:
          - P5 (Tier 1) vs P15 (Tier 3)
          - Tier 1 승리
          - 결정: 보안 검증 필수, 배포 지연

        # Case 2: P8 vs P15 (이미 해결됨)
        상황: "테스트 90% vs 80% 수렴"
        P17 적용:
          - 충돌 없음 (Zero-Based로 80% 통일)
          - P17 불필요 (예방 효과)

      bad: |
        # P17 없이 충돌 처리
        AI: "P5와 P15가 충돌하네요... 음... 이번엔 P15를?"
        (다음번: P5 선택 → 일관성 없음)


# ==============================================================================
# 도구 매핑 (Tools Mapping)
# ==============================================================================

tools:
  # 각 도구가 어떤 헌법 조항을 검증/집행하는지 명시

  TaskExecutor:
    description: "YAML 계약서 실행 엔진"
    enforces:
      - "P1: YAML 계약서 우선"
      - "P2: 증거 기반 개발"
    role: "핵심 실행 엔진"
    layer: 2

  ConstitutionalValidator:
    description: "헌법 준수 검증기"
    enforces:
      - "ALL: 모든 헌법 조항"
      - "P11: 원칙 충돌 검증 (수동)"
      - "P13: 헌법 수정 검증 (수동)"
    role: "헌법 검증"
    layer: 2
    note: "P11, P13은 현재 수동 검토 (자동화 예정)"

  DeepAnalyzer:
    description: "심층 코드 분석기"
    enforces:
      - "P4: SOLID 원칙"
      - "P5: 보안 우선"
      - "P7: Hallucination 방지"
    role: "코드 품질 검증"
    layer: 3
    output: "AnalysisResult (품질 점수 0-10)"

  TeamStatsAggregator:
    description: "팀 통계 집계기"
    enforces:
      - "P6: 품질 게이트"
    role: "전체 프로젝트 통계"
    layer: 3
    output: "TeamStats + Quality Gate (Pass/Fail)"

  ObsidianBridge:
    description: "Obsidian 자동 동기화"
    enforces:
      - "P3: 지식 자산화"
    role: "지식 관리"
    layer: 6
    target_time: "3초"

  StreamlitDashboard:
    description: "Constitution 준수 현황판"
    enforces: []
    role: "시각화 (검증 안 함)"
    layer: 7
    displays:
      - "P6 Quality Gate (Pass/Fail)"
      - "P4, P5 위반 Hotspots TOP 5"
      - "P6 추세 (시간별 품질 변화)"

  VerificationCache:
    description: "검증 결과 캐싱"
    enforces: []
    role: "성능 최적화"
    layer: 4

  CriticalFileDetector:
    description: "스마트 파일 분류"
    enforces: []
    role: "검증 우선순위 결정"
    layer: 4

  DevAssistant:
    description: "실시간 파일 감시"
    enforces:
      - "P4: SOLID 원칙 (실시간)"
      - "P5: 보안 (실시간)"
    role: "실시간 헌법 검증"
    layer: 3

  BenchmarkAnalyzer:
    description: "경쟁사 벤치마킹 분석기"
    enforces:
      - "P16: 경쟁사 벤치마킹"
    role: "경쟁 분석 및 차별화 전략 수립"
    layer: 3
    components:
      - "CompetitorSearcher: 경쟁사 검색 및 순위화"
      - "ProductAnalyzer: 제품 분석 (강점/약점)"
      - "DifferentiationGenerator: 차별화 전략 생성"
    performance:
      - "전체 파이프라인: <15분"
      - "경쟁사당 분석: <3분"
    output: "BenchmarkResult (competitors + differentiation)"

  P16Validator:
    description: "P16 게이트 검증기"
    enforces:
      - "P16: 경쟁사 벤치마킹"
    role: "YAML 계약서의 benchmarking 섹션 검증"
    layer: 2
    checks:
      - "최소 3개 경쟁사"
      - "최소 3개 차별화 포인트"
      - "필수 필드 존재 검증"
    integration: "TaskExecutor 게이트 시스템"


# ==============================================================================
# 워크플로우 (Workflows)
# ==============================================================================

workflows:

  # 새 기능 추가 워크플로우
  feature_development:
    description: "새 기능을 추가하는 표준 워크플로우"
    steps:
      - step: 1
        action: "YAML 계약서 작성"
        file: "TASKS/FEAT-YYYY-MM-DD-NN.yaml"
        articles: ["P1"]

      - step: 2
        action: "헌법 게이트 정의"
        field: "gates:"
        articles: ["P4", "P5", "P6"]

      - step: 3
        action: "TaskExecutor 실행"
        command: "python scripts/task_executor.py TASKS/..."
        articles: ["P2"]

      - step: 4
        action: "DeepAnalyzer 검증"
        automatic: true
        articles: ["P4", "P5", "P7"]

      - step: 5
        action: "Obsidian 동기화"
        automatic: true
        articles: ["P3"]

      - step: 6
        action: "Quality Gate 확인"
        location: "http://localhost:8501"
        articles: ["P6"]

  # 코드 작성 워크플로우
  code_development:
    description: "실시간 코드 검증 워크플로우"
    steps:
      - step: 1
        action: "Dev Assistant 실행"
        command: "python scripts/dev_assistant.py"

      - step: 2
        action: "코드 작성 및 저장"
        automatic_check: "파일 저장 시 자동 검증"

      - step: 3
        action: "즉시 피드백"
        speed: "< 200ms"
        articles: ["P4", "P5"]

      - step: 4
        action: "대시보드 확인"
        location: "http://localhost:8501"
        articles: ["P6"]


# ==============================================================================
# 품질 점수 계산 (Quality Scoring)
# ==============================================================================

scoring:
  formula: |
    시작: 10.0점

    감점:
      - Ruff 위반: -0.2점 (최대 -2.0점)
      - SOLID 위반: -0.5점 (최대 -3.0점)
      - 보안 이슈: -1.0점 (최대 -4.0점)
      - Hallucination: -0.1점 (최대 -1.0점)

    최종: 0.0 - 10.0점

  weights:
    ruff: "20%"
    solid: "30%"
    security: "40%"
    hallucination: "10%"

  thresholds:
    excellent: "≥ 9.0 (A등급)"
    good: "8.0 - 8.9 (B등급)"
    acceptable: "7.0 - 7.9 (C등급)"
    needs_improvement: "6.0 - 6.9 (D등급)"
    failing: "< 6.0 (F등급)"


# ==============================================================================
# 거버넌스 (Governance)
# ==============================================================================

governance:

  amendment_process:
    description: "헌법 수정 절차"
    steps:
      - "변경 이유 문서화"
      - "프로젝트 관리자 리뷰"
      - "하위 호환성 평가"
      - "마이그레이션 계획"
      - "버전 증가 (MAJOR/MINOR/PATCH)"

  compliance_enforcement:
    automated:
      - "Pre-commit hooks"
      - "CI/CD 파이프라인"
      - "DeepAnalyzer 자동 검증"
      - "Dev Assistant 실시간 검증"

    manual:
      - "코드 리뷰"
      - "PR 체크리스트"
      - "분기별 헌법 리뷰"

  exception_handling:
    description: "정당한 헌법 위반 처리"
    requirements:
      - "Complexity Tracking에 문서화"
      - "위반 이유 명시"
      - "코드 리뷰 승인 필요"
      - "향후 리팩토링 TODO 추가"

  review_schedule:
    quarterly: "3개월마다 헌법 리뷰"
    triggers:
      - "주요 아키텍처 변경"
      - "새 도구 추가"
      - "반복적인 헌법 위반"


# ==============================================================================
# 메트릭스 (Metrics)
# ==============================================================================

metrics:

  quality_gate:
    pass_conditions:
      - "평균 품질 ≥ 7.0"
      - "통과율 ≥ 80%"
      - "Critical 보안 이슈 0개"

    display: "Streamlit Dashboard"

  time_savings:
    obsidian_sync: "95% (20min → 3sec)"
    code_verification: "100% (수동 → 자동 0.2sec)"
    annual_total: "264 hours"

  trust_scores:
    constitutional_guards: "7.6 (Hexagon)"
    evidence_tracker: "8.0 (GrowthBook)"
    project_steering: "8.3 (cc-sdd)"
    task_executor: "8.0+"


# ==============================================================================
# 빠른 참조 (Quick Reference)
# ==============================================================================

quick_reference:

  decision_tree: |
    새 작업 시작 전:
      1. YAML 계약서 있나? (P1)
      2. 헌법 게이트 정의했나? (P4, P5, P6)
      3. 증거 수집 설정했나? (P2)
      4. Obsidian 동기화 가능한가? (P3)

    코드 작성 전:
      1. Dev Assistant 실행했나?
      2. 테스트 먼저 작성했나? (P8)
      3. 보안 이슈 없나? (P5)
      4. SOLID 준수하나? (P4)

    커밋 전:
      1. Conventional Commits 형식? (P9)
      2. Quality Gate PASS? (P6)
      3. 이모지 없나? (P10)

  common_commands:
    start_dev_assistant: "python scripts/dev_assistant.py"
    run_task: "python scripts/task_executor.py TASKS/*.yaml"
    check_quality: "streamlit run streamlit_app.py"
    run_deep_analysis: "python scripts/deep_analyzer.py <file>"


# ==============================================================================
# 버전 히스토리 (Version History)
# ==============================================================================

version_history:
  - version: "1.0.0"
    date: "2025-10-23"
    changes:
      - "초기 헌법 작성"
      - "10개 핵심 조항 정의"
      - "도구 매핑 완료"
      - "워크플로우 정의"
    rationale: "실행형 자산 시스템의 기준 확립"


# ==============================================================================
# 우선순위 (Priorities)
# ==============================================================================

priorities:
  critical:
    - "P1: YAML 계약서 우선"
    - "P2: 증거 기반 개발"
    - "P5: 보안 우선"

  high:
    - "P3: 지식 자산화"
    - "P4: SOLID 원칙"
    - "P6: 품질 게이트"
    - "P8: 테스트 우선"

  medium:
    - "P7: Hallucination 방지"
    - "P9: Conventional Commits"
    - "P10: Windows 인코딩"


# ==============================================================================
# 끝
# ==============================================================================

# 이 헌법은 모든 개발 관행보다 우선합니다.
# 충돌 시 헌법이 우선합니다.
